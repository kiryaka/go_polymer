
<polymer-element name="median-chart" attributes="rawdata variants">
    <template>
        <style shim-shadowdom>

            .axis path,
            .axis line {
                fill: none;
                stroke: #000;
                shape-rendering: crispEdges;
            }

            svg {
                font: 10px sans-serif;
            }

            text{
                fill: #666;
            }

            .grid .tick {
                stroke: lightgrey;
                opacity: 0.5;
            }

            .tick line {
                stroke: lightgrey;
                opacity: 0.5;
            }

            .pline {
                fill: none;
                stroke: green;
                stroke-width: 2px;
            }

            .nline {
                fill: none;
                stroke: red;
                stroke-width: 2px;
            }

            .initial{

            }

            .budget{
                opacity: 0.3;
                stroke-width: 1px;
            }

            .pcircle {
                stroke: green;
                fill: white;
                /*fill-opacity: .7;*/
            }

            .ncircle {
                stroke: red;
                fill: white;
                /*fill-opacity: .7;*/
            }

        </style>

        <div id="map"></div>
    </template>

    <script>
        Polymer({
            ready: function(){

            },
            redraw: function(){
                var margin = {top: 20, right: 30, bottom: 30, left: 40},
                        width = 700 - margin.left - margin.right,
                        height = 700 - margin.top - margin.bottom;

                var x = d3.scale.linear()
                        .range([0, width]);

                var y = d3.scale.linear()
                        .range([height, 0]);

                var xAxis = d3.svg.axis()
                        .scale(x)
                        .orient("bottom")
                        .tickFormat(d3.format(".1%"));

                var yAxis = d3.svg.axis()
                        .scale(y)
                        .orient("right")
                        .ticks(40);

                var line = d3.svg.line()
                        .interpolate(interpolateSankey)
                        .x(function(d) {
                            return x(d.x);
                        })
                        .y(function(d) {
                            return y(d.y);
                        });

                var svg = d3.select(this.$.map).append("svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                var dom = this.positive[0].data.concat(this.negative[0].data);
                x.domain(d3.extent(dom, function(d) { return d.x; })).nice();
                y.domain(d3.extent(dom, function(d) { return d.y; })).nice();

                svg.append("g")
                        .attr("class", "x axis")
                        .attr("transform", "translate(0," + y(0) + ")")
//                        .attr("transform", "translate(0," + height + ")")
                        .call(xAxis);

                svg.append("g")
                        .attr("class", "y axis")
                        .attr("transform", "translate(" + x(1) + ", 0)")
                        .call(yAxis);

                var numberOfTicks = 10;

                var yAxisGrid = yAxis.ticks(numberOfTicks)
                        .tickSize(width, 0)
                        .tickFormat("")
                        .orient("right");

                var xAxisGrid = xAxis.ticks(numberOfTicks)
                        .tickSize(-height, 0)
                        .tickFormat("")
                        .orient("top");

                svg.append("g")
                        .classed('y', true)
                        .classed('grid', true)
                        .call(yAxisGrid);

                svg.append("g")
                        .classed('x', true)
                        .classed('grid', true)
                        .call(xAxisGrid);

                var c20 = d3.scale.category20();
                for (var i = 0; i < this.positive.length; i++) {

                    var inClass = i == 0 ? " initial" : " budget";

                    var data = this.positive[i];

                    var p = svg.append("path")
                            .datum(data.data)
                            .attr("class", "pline" + inClass)
                            .attr("d", line)
                            .attr("id", "b" + data.id);

                    var g = svg.append("g").datum(data.data)
                            .attr("transform", function(d) {
                                return "translate(" + (x(0) - 70) +"," + ( i*10 ) + ")";
                            });
                    g.append('rect')
                            .attr("width", 70)
                            .attr("height", 8)
                            .style("fill", c20(data.id));
//                    g.append('text')
//                            .attr("x", 20)
//                            .attr("y", 30)
//                            .attr("dy", ".35em")
//                            .text("haha");

                    if (i > 0 ) p.style("stroke", c20(data.id));


                    data = this.negative[i]
                    var n = svg.append("path")
                            .datum(data.data)
                            .attr("class", "nline" + inClass)
                            .attr("d", line)
                            .style("stroke", data.color)
                            .attr("id", "b" + data.id);

                    if (i > 0 ) n.style("stroke", c20(data.id));

                }

                function onmouseover(d){
                    var svg = d3.select(this.ownerSVGElement);
                    svg.selectAll("#" + this.id)
                            .style("fill", "red")
                            .style("stroke", "blue");

                }

                function onmouseout(d){
                    var svg = d3.select(this.ownerSVGElement);
                    svg.selectAll("#" + this.id)
                            .style("fill", "none")
                            .style("stroke", "green");

                }

                function clasterize(d, i, a ){
                    if ( i == 0 ) return true;
                    return Math.abs(d.x - a[i-1].x) > 0.005;
                }

                function interpolateSankey(points) {
                    var x0 = points[0][0], y0 = points[0][1], x1, y1, x2,
                            path = [x0, ",", y0],
                            i = 0,
                            n = points.length;
                    while (++i < n) {
                        x1 = points[i][0], y1 = points[i][1], x2 = (x0 + x1) / 2;
                        path.push("C", x2, ",", y0, " ", x2, ",", y1, " ", x1, ",", y1);
                        x0 = x1, y0 = y1;
                    }
                    return path.join("");
                }

            },
            processData: function(){
                this.positive = [];
                this.negative = [];
                var _this = this;
                this.rawdata.forEach(function(d){
                    _this.impMax = d3.max(d.data, function(d){return d.impact});
                    _this.impMin = d3.min(d.data, function(d){return d.impact});
                    _this.positive.push(_this.buildData(d, d.data.sort(_this.positiveSort.bind(_this))));
                    _this.negative.push(_this.buildData(d, d.data.sort(_this.negativeSort.bind(_this))));
                });
            },
            positiveSort: function(a,b){
                if (a.impact == this.impMax) return -1;
                if (b.impact == this.impMax) return 1;
                return d3.descending(a.weight, b.weight);
            },
            negativeSort: function(a,b){
                if (a.impact == this.impMin) return -1;
                if (b.impact == this.impMin) return 1;
                return d3.ascending(a.weight, b.weight);
            },
            buildData: function(data, arr){
                var result = [];
                var prob = [], imp = [], probSum = 0;
                for(var i = 0; i < arr.length; i++){
                    probSum += arr[i].prob;
                    prob.push(arr[i].prob);
                    imp.push(arr[i].impact);

                    var median = imp.reduce(function(previousValue, currentValue, index) {
                        return previousValue + ( probSum || 0 > 0 ? currentValue*prob[index]/probSum : 0);
                    }, 0);

                    result.push({x: probSum > 1 ? 1 : probSum , y: median});
                }
                return {data:result, id: data.id, budget: data.budget};
            },
            rawdataChanged: function(o, n){
                if (n && n.length > 0){
                    this.processData();
                    this.redraw();
                }
            },
            variantsChanged: function(o, n){
                if (n.length == 0) return;

                var arr = [];
                var processed = d3.set([]);

                this.scenNumber = Math.pow(2, this.variants.length)

                for (var bud = 0; bud < this.scenNumber; bud++) {

                    var data = [];
                    var budget = 0;

                    var changed = "|";
                    for (var scenario = 0; scenario < this.scenNumber; scenario++) {
                        var obj = {id: scenario, prob: 1, impact: 0, color: "", endpoints: []}
                        for (var factor = 0; factor < this.variants.length; factor++) {
                            var ep = (scenario & (1 << factor ) ) > 0 ? 1 : 0
                            var prob = - -this.variants[factor].endpoints[ep].prob;

                            var diff = 0;

                            if ((bud & (1 << factor ) ) > 0){
                                diff = (this.variants[factor].probDiff || 0);
                                if (ep == 0){
                                    prob -= -diff;
                                }else{
                                    prob += -diff;
                                }
                            }
                            changed += (diff > 0) ? "1" : "0";

                            obj.endpoints.push(ep)

                            obj.impact -= -this.variants[factor].endpoints[ep].impact;
                            obj.prob *= prob;
                        }

                        obj.weight = Math.pow(obj.impact, 5)*obj.prob;
                        data.push(obj);
                    }


                    if (processed.has(changed)) continue;

                    processed.add(changed);

                    for (var factor = 0; factor < this.variants.length; factor++) {
                        var ep = (bud & (1 << factor ) ) > 0 ? 1 : 0
                        if (ep == 1) budget -= -(this.variants[factor].cost || 0);
                    }

                    arr.push({data: data, budget: budget, id: bud});
                }

                this.rawdata = arr;
            }
        });
    </script>
</polymer-element>